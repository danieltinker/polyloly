---
description: Cursor rules for building an esports algorithmic trading platform
globs: ["**/*.py", "**/*.sql"]
alwaysApply: true
---

# Esports Algotrader Cursor Rules

You are an expert Python developer building an esports algorithmic trading platform that automates betting decisions on competitive gaming events (CS2, LoL, Dota 2, Valorant).

## Project Overview

This platform:
- Ingests real-time esports data from PandaScore API
- Calculates expected value using ML probability predictions
- Executes trades with proper risk management
- Monitors performance via Telegram alerts

## Tech Stack

- **Language**: Python 3.11+
- **Async**: asyncio, aiohttp for all I/O
- **Database**: PostgreSQL (SQLAlchemy async) + Redis (caching)
- **ML**: scikit-learn, XGBoost, pandas, numpy
- **APIs**: PandaScore (esports data), The Odds API (betting odds)
- **Monitoring**: Telegram bot, Grafana

## Code Standards

### Type Hints (Required)
```python
# Always use type hints
async def get_matches(self, game: str, limit: int = 10) -> list[Match]:
    ...

# Use Optional for nullable
def process(self, data: Optional[dict] = None) -> Signal:
    ...
```

### Dataclasses for Models
```python
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional

@dataclass
class Match:
    id: str
    game: str
    team1: str
    team2: str
    odds: dict = field(default_factory=dict)
    start_time: Optional[datetime] = None
```

### Async/Await Patterns
```python
# Always use async for I/O
async def fetch_data(self) -> dict:
    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers=self.headers) as resp:
            return await resp.json()

# Use gather for concurrent calls
results = await asyncio.gather(
    self.get_matches("csgo"),
    self.get_matches("lol"),
    self.get_matches("dota2")
)
```

### Error Handling
```python
# Custom exceptions
class RateLimitError(Exception):
    pass

class APIError(Exception):
    def __init__(self, status: int, message: str):
        self.status = status
        super().__init__(message)

# Always handle gracefully
try:
    data = await self.fetch_data()
except RateLimitError:
    await asyncio.sleep(60)
    data = await self.fetch_data()
except APIError as e:
    logger.error(f"API error: {e.status} - {e}")
    raise
```

### Logging
```python
import logging

logger = logging.getLogger(__name__)

# Log all trades with full context
logger.info(
    "Trade executed",
    extra={
        "match_id": signal.match_id,
        "side": signal.signal_type.value,
        "stake": order.stake,
        "odds": order.odds,
        "ev": signal.expected_value
    }
)
```

## Architecture Patterns

### Strategy Pattern (Trading Strategies)
```python
from abc import ABC, abstractmethod

class Strategy(ABC):
    @abstractmethod
    def analyze(self, match: Match, history: list) -> Signal:
        pass
    
    @abstractmethod
    def backtest(self, data: list) -> BacktestResult:
        pass

class ValueBettingStrategy(Strategy):
    def analyze(self, match: Match, history: list) -> Signal:
        # Implementation
        ...
```

### Repository Pattern (Database)
```python
class MatchRepository:
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def get_by_id(self, match_id: str) -> Optional[Match]:
        result = await self.session.execute(
            select(MatchModel).where(MatchModel.id == match_id)
        )
        return result.scalar_one_or_none()
    
    async def save(self, match: Match) -> None:
        self.session.add(MatchModel.from_entity(match))
        await self.session.commit()
```

### Factory Pattern (API Clients)
```python
def create_data_provider(provider: str, config: Config) -> DataProvider:
    providers = {
        "pandascore": PandaScoreClient,
        "odds_api": OddsAPIClient,
    }
    return providers[provider](config)
```

## Key Components

### 1. Data Layer
- `data/providers/`: API clients (PandaScore, Odds API)
- `data/repositories/`: Database access
- `data/models.py`: Dataclass definitions

### 2. Domain Layer
- `domain/entities.py`: Core business entities
- `domain/services.py`: Business logic

### 3. Strategy Layer
- `strategies/base.py`: Abstract Strategy class
- `strategies/value_betting.py`: EV-based betting
- `strategies/arbitrage.py`: Cross-book arbitrage

### 4. Execution Layer
- `execution/engine.py`: Order management
- `execution/risk_manager.py`: Risk controls
- `execution/position_tracker.py`: P&L tracking

### 5. ML Layer
- `ml/features.py`: Feature engineering
- `ml/models.py`: Model definitions
- `ml/training.py`: Training pipeline

## Risk Management Rules

CRITICAL: Always implement these safeguards:

```python
class RiskManager:
    MAX_STAKE_PER_BET = 50.0      # Never exceed
    MAX_DAILY_LOSS = 200.0        # Circuit breaker
    KELLY_FRACTION = 0.25         # Quarter Kelly
    
    def approve(self, signal: Signal) -> bool:
        # Check daily loss limit
        if self.daily_pnl < -self.MAX_DAILY_LOSS:
            return False
        
        # Cap stake
        if signal.recommended_stake > self.MAX_STAKE_PER_BET:
            signal.recommended_stake = self.MAX_STAKE_PER_BET
        
        return True
```

## API Rate Limiting

PandaScore free tier: 1000 requests/hour

```python
from asyncio import Semaphore
from datetime import datetime, timedelta

class RateLimiter:
    def __init__(self, max_requests: int, period: timedelta):
        self.max_requests = max_requests
        self.period = period
        self.requests = []
        self.semaphore = Semaphore(10)  # Concurrent limit
    
    async def acquire(self):
        async with self.semaphore:
            now = datetime.now()
            self.requests = [r for r in self.requests 
                           if r > now - self.period]
            
            if len(self.requests) >= self.max_requests:
                sleep_time = (self.requests[0] + self.period - now).total_seconds()
                await asyncio.sleep(sleep_time)
            
            self.requests.append(now)
```

## Testing Requirements

- Unit tests for all strategies and risk logic
- Integration tests with mocked API responses
- Backtest validation (no look-ahead bias)
- Minimum 85% coverage

```python
# tests/unit/test_strategies.py
import pytest
from unittest.mock import Mock

@pytest.fixture
def mock_match():
    return Match(
        id="test_123",
        game="csgo",
        team1="Team A",
        team2="Team B",
        odds={"team1": 2.0, "team2": 1.8}
    )

def test_value_betting_positive_ev(mock_match):
    strategy = ValueBettingStrategy(model=MockModel(prob=0.6))
    signal = strategy.analyze(mock_match, history=[])
    
    assert signal.signal_type == SignalType.BUY_TEAM1
    assert signal.expected_value > 0.05
```

## Security

NEVER commit:
- API keys (use .env)
- Database credentials
- Telegram bot tokens

Always use:
```python
import os
from dotenv import load_dotenv

load_dotenv()
API_KEY = os.getenv("PANDASCORE_API_KEY")
```

## Common Pitfalls to Avoid

1. **Future data leakage in backtests** - Always use time-based train/test splits
2. **Uncapped stakes** - Always apply Kelly fraction and max stake limits
3. **Ignoring API rate limits** - Implement rate limiting with backoff
4. **Silent failures** - Log all errors and send alerts
5. **Missing risk circuit breakers** - Always implement daily loss limits

## Helpful Commands

```bash
# Run tests
pytest tests/ -v --cov=src --cov-report=html

# Backtest a strategy
python scripts/backtest.py --strategy value_betting --start 2024-01-01

# Train model
python scripts/train_model.py --game csgo --output models/csgo_v1.pkl

# Start in paper trading mode
PAPER_TRADING=true python -m src.main
```
